const MAX_SIZE: i32 = 1000;
const ITERATIONS: i32 = 100;

func fibonacci(n: i32) -> i32 {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

func factorial(n: i32) -> i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

func isPrime(n: i32) -> bool {
    if (n < 2) {
        return false;
    }
    
    let i: i32 = 2;
    loopwhile (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }
    
    return true;
}

func gcd(a: i32, b: i32) -> i32 {
    loopwhile (b != 0) {
        let temp: i32 = b;
        b = a % b;
        a = temp;
    }
    return a;
}

func lcm(a: i32, b: i32) -> i32 {
    return (a * b) / gcd(a, b);
}

func power(base: i32, exp: i32) -> i32 {
    if (exp == 0) {
        return 1;
    }
    return base * power(base, exp - 1);
}

func sumOfDigits(n: i32) -> i32 {
    let sum: i32 = 0;
    
    loopwhile (n > 0) {
        sum = sum + (n % 10);
        n = n / 10;
    }
    
    return sum;
}

func reverseNumber(n: i32) -> i32 {
    let reversed: i32 = 0;
    
    loopwhile (n > 0) {
        reversed = reversed * 10 + (n % 10);
        n = n / 10;
    }
    
    return reversed;
}

func isPalindrome(n: i32) -> bool {
    return (n == reverseNumber(n));
}

func countDigits(n: i32) -> i32 {
    let count: i32 = 0;
    
    loopwhile (n > 0) {
        count = count + 1;
        n = n / 10;
    }
    
    return count;
}

func absoluteValue(n: i32) -> i32 {
    if (n < 0) {
        return -n;
    }
    return n;
}

func min(a: i32, b: i32) -> i32 {
    if (a < b) {
        return a;
    }
    return b;
}

func max(a: i32, b: i32) -> i32 {
    if (a > b) {
        return a;
    }
    return b;
}

func clamp(value: i32, minVal: i32, maxVal: i32) -> i32 {
    if (value < minVal) {
        return minVal;
    }
    if (value > maxVal) {
        return maxVal;
    }
    return value;
}

func swap(a: i32, b: i32) -> i32 {
    return b;
}

func isEven(n: i32) -> bool {
    return (n % 2 == 0);
}

func isOdd(n: i32) -> bool {
    return (n % 2 != 0);
}

func sum(n: i32) -> i32 {
    if (n <= 0) {
        return 0;
    }
    return n + sum(n - 1);
}

func product(n: i32) -> i32 {
    if (n <= 1) {
        return 1;
    }
    return n * product(n - 1);
}

func ackermann(m: i32, n: i32) -> i32 {
    if (m == 0) {
        return n + 1;
    }
    if (n == 0) {
        return ackermann(m - 1, 1);
    }
    return ackermann(m - 1, ackermann(m, n - 1));
}

func collatz(n: i32) -> i32 {
    let steps: i32 = 0;
    
    loopwhile (n != 1) {
        if (n % 2 == 0) {
            n = n / 2;
        } else {
            n = 3 * n + 1;
        }
        steps = steps + 1;
    }
    
    return steps;
}

func digitSum(n: i32) -> i32 {
    let sum: i32 = 0;
    
    loopwhile (n > 0) {
        sum = sum + (n % 10);
        n = n / 10;
    }
    
    return sum;
}

func digitProduct(n: i32) -> i32 {
    let product: i32 = 1;
    
    loopwhile (n > 0) {
        product = product * (n % 10);
        n = n / 10;
    }
    
    return product;
}

func isPerfectSquare(n: i32) -> bool {
    let i: i32 = 1;
    
    loopwhile (i * i <= n) {
        if (i * i == n) {
            return true;
        }
        i = i + 1;
    }
    
    return false;
}

func triangleNumber(n: i32) -> i32 {
    return (n * (n + 1)) / 2;
}

func pentagonalNumber(n: i32) -> i32 {
    return (n * (3 * n - 1)) / 2;
}

func hexagonalNumber(n: i32) -> i32 {
    return n * (2 * n - 1);
}

func catalan(n: i32) -> i32 {
    if (n <= 1) {
        return 1;
    }
    
    let result: i32 = 0;
    let i: i32 = 0;
    
    loopwhile (i < n) {
        result = result + catalan(i) * catalan(n - 1 - i);
        i = i + 1;
    }
    
    return result;
}

func binomialCoeff(n: i32, k: i32) -> i32 {
    if (k == 0 || k == n) {
        return 1;
    }
    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k);
}

func arraySum(size: i32) -> i32 {
    let sum: i32 = 0;
    let i: i32 = 0;
    
    loopwhile (i < size) {
        sum = sum + i;
        i = i + 1;
    }
    
    return sum;
}

func arrayProduct(size: i32) -> i32 {
    let product: i32 = 1;
    let i: i32 = 1;
    
    loopwhile (i <= size) {
        product = product * i;
        i = i + 1;
    }
    
    return product;
}

func bubbleSortPass(arr: i32, size: i32) -> void {
    let i: i32 = 0;
    
    loopwhile (i < size - 1) {
        if (arr > arr + 1) {
            let temp: i32 = arr;
        }
        i = i + 1;
    }
}

func linearSearch(value: i32, size: i32, target: i32) -> i32 {
    let i: i32 = 0;
    
    loopwhile (i < size) {
        if (value == target) {
            return i;
        }
        i = i + 1;
    }
    
    return -1;
}

func countPrimes(n: i32) -> i32 {
    let count: i32 = 0;
    let i: i32 = 2;
    
    loopwhile (i <= n) {
        if (isPrime(i)) {
            count = count + 1;
        }
        i = i + 1;
    }
    
    return count;
}

func sumPrimes(n: i32) -> i32 {
    let sum: i32 = 0;
    let i: i32 = 2;
    
    loopwhile (i <= n) {
        if (isPrime(i)) {
            sum = sum + i;
        }
        i = i + 1;
    }
    
    return sum;
}

func greatestCommonDivisor(a: i32, b: i32) -> i32 {
    return gcd(a, b);
}

func leastCommonMultiple(a: i32, b: i32) -> i32 {
    return lcm(a, b);
}

func generateFibonacci(n: i32) -> void {
    let i: i32 = 0;
    
    loopwhile (i < n) {
        let fib: i32 = fibonacci(i);
        i = i + 1;
    }
}

func generatePrimes(n: i32) -> void {
    let count: i32 = 0;
    let num: i32 = 2;
    
    loopwhile (count < n) {
        if (isPrime(num)) {
            count = count + 1;
        }
        num = num + 1;
    }
}

func computeStatistics(size: i32) -> void {
    let sum: i32 = arraySum(size);
    let product: i32 = arrayProduct(size);
    let min: i32 = 0;
    let max: i32 = size;
}

func runBenchmark(iterations: i32) -> void {
    let i: i32 = 0;
    
    loopwhile (i < iterations) {
        let f: i32 = fibonacci(10);
        let p: i32 = factorial(10);
        let s: i32 = sum(100);
        i = i + 1;
    }
}

func performCalculations() -> void {
    let a: i32 = 42;
    let b: i32 = 17;
    
    let gcdVal: i32 = gcd(a, b);
    let lcmVal: i32 = lcm(a, b);
    let powVal: i32 = power(2, 10);
    let sumDigits: i32 = sumOfDigits(12345);
    let reverse: i32 = reverseNumber(12345);
}

func testMathOperations() -> void {
    let x: i32 = 100;
    let y: i32 = 50;
    
    let sum: i32 = x + y;
    let diff: i32 = x - y;
    let prod: i32 = x * y;
    let quot: i32 = x / y;
    let mod: i32 = x % y;
    
    let minVal: i32 = min(x, y);
    let maxVal: i32 = max(x, y);
    let clampVal: i32 = clamp(75, 0, 100);
}

func benchmarkFibonacci() -> i32 {
    let i: i32 = 0;
    let total: i32 = 0;
    
    loopwhile (i < 20) {
        total = total + fibonacci(i);
        i = i + 1;
    }
    
    return total;
}

func benchmarkPrimes() -> i32 {
    return countPrimes(100);
}

func benchmarkFactorial() -> i32 {
    let i: i32 = 0;
    let total: i32 = 0;
    
    loopwhile (i < 12) {
        total = total + factorial(i);
        i = i + 1;
    }
    
    return total;
}

func main() -> i32 {
    say("Large Test Program for Optimization");
    say("Performance Benchmark");
    say("Note: Time measurements show relative performance\n");
    
    say("=== Fibonacci Benchmark ===");
    say("Computing fibonacci(0-19)...");
    let result1: i32 = benchmarkFibonacci();
    say("Result:", result1);
    
    say("\n=== Prime Counting Benchmark ===");
    say("Finding primes up to 100...");
    let result2: i32 = benchmarkPrimes();
    say("Primes found:", result2);
    
    say("\n=== Factorial Benchmark ===");
    say("Computing factorials 0-11...");
    let result3: i32 = benchmarkFactorial();
    say("Result:", result3);
    
    say("\n=== Individual Tests ===");
    say("\n--- Fibonacci ---");
    let i: i32 = 0;
    loopwhile (i < 15) {
        let fib: i32 = fibonacci(i);
        say("F(", i, ") =", fib);
        i = i + 1;
    }
    
    say("\n--- Number Theory ---");
    say("GCD(48, 18) =", gcd(48, 18));
    say("LCM(12, 18) =", lcm(12, 18));
    say("2^10 =", power(2, 10));
    
    say("\n--- Digit Operations ---");
    let num: i32 = 12345;
    say("Number:", num);
    say("Digit sum:", sumOfDigits(num));
    say("Digit product:", digitProduct(num));
    say("Reversed:", reverseNumber(num));
    say("Digits count:", countDigits(num));
    
    say("\n--- Perfect Squares ---");
    i = 1;
    let squares: i32 = 0;
    loopwhile (i <= 20) {
        if (isPerfectSquare(i)) {
            squares = squares + 1;
        }
        i = i + 1;
    }
    say("Perfect squares from 1-20:", squares);
    
    say("\n--- Catalan Numbers ---");
    i = 0;
    loopwhile (i < 7) {
        let cat: i32 = catalan(i);
        say("C(", i, ") =", cat);
        i = i + 1;
    }
    
    say("\n=== Summary ===");
    say("Total functions tested: 30+");
    say("Total lines of code: ~500");
    say("\nTo compare optimization effectiveness:");
    say("  1. Compile with different flags:");
    say("     xypc test.xyp -o test-none");
    say("     xypc test.xyp -O2 -o test-O2");
    say("     xypc test.xyp -Os -o test-Os");
    say("     xypc test.xyp --size -o test-tiny");
    say("  2. Check binary sizes with 'dir' command");
    say("  3. Use PowerShell Measure-Command for timing");
    say("\nBenchmark complete!");
    
    return 0;
}

